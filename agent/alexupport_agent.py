"""
Main Alexupport agent
This module contains the main agent which orchestrates the other microagents
"""

from typing import List

from langchain.memory import ConversationBufferMemory
from langchain.schema import HumanMessage, AIMessage

from agent.answer_generator import AnswerGenerator
from agent.followup_generator import FollowUpGenerator
from agent.input_refiner import InputRefiner
from agent.is_answerable_agent import IsAnswerableAgent
from agent.is_relevant_agent import IsRelevantAgent
from agent.information_retriever import InformationRetriever, client
from agent.llm_client import LLMClient

LLM_CLIENT = LLMClient()

class AlexupportAgent:
    """Main Alexupport agent class"""

    def __init__(self):

        self.introduction = """
        Hi! I am Alexupport ðŸ¤–, your Amazon AI assistant. I am here to answer your questions regarding different Amazon products.
        Start by choosing a product ID, and then ask me anything about it!
        """

        self.chat_start = "Let's have a chat about {product_title}.\nAsk me anything!"

        self.memory = ConversationBufferMemory(return_messages=True)

        # Initializing all microagents
        self.input_refiner = InputRefiner(llm_client=LLM_CLIENT)
        self.information_retriever = InformationRetriever(qdrant_client=client, llm_client=LLM_CLIENT)
        self.is_answerable_agent = IsAnswerableAgent(llm_client=LLM_CLIENT, chat_history=self.memory)
        self.answer_generator = AnswerGenerator(llm_client=LLM_CLIENT, chat_history=self.memory)
        self.followup_generator = FollowUpGenerator(llm_client=LLM_CLIENT)
        self.is_relevant_generator = IsRelevantAgent(llm_client=LLM_CLIENT)

    def get_agent_introduction(self) -> str:
        """
        Displays the agent introduction and instructions to the user upon activation.

        Returns:
        - str; The agent introduction and instructions to the user upon activation.
        """

        return self.introduction

    def get_agent_chat_start(self, product_title: str) -> str:
        """
        Displays the initial chat prompt to the user.

        Parameters:
        - product_title: str; The title of the product being discussed.

        Returns:
        - str; The initial chat prompt to the user.
        """

        if product_title != "No title found":
            return self.chat_start.format(product_title=product_title)
        return "Let's have a chat about your product.\nAsk me anything!"

    def _format_final_answer(self, answer: str, follow_ups: List[str]):
        """
        Formats the final answer with follow-up questions.

        Parameters:
        - answer: str; The generated answer to the user's query.
        - follow_ups: List[str]; A list of follow-up questions related to the user's query.

        Returns:
        - str; The formatted final answer with follow-up questions.
        """

        formatted_answer = f"""
        {answer}
        Here are some follow-up questions you might consider:
        {"; ".join([f for f in follow_ups])}
        """

        return formatted_answer

    def answer_user_query(self, user_query: str, product_asin: str) -> str:
        """
        Main Alexupport pipeline.

        Parameters:
        - user_query: str; The query input by the user.
        - product_asin: str; The ASIN of the product being queried.

        Returns:
        - str; The final answer generated by the agent.
        """
        # Step 0 - Append the user query
        self.memory.chat_memory.messages.append(HumanMessage(content=user_query))

        # Step 1 - Refine user query
        refined_query = self.input_refiner.refine_input(user_input=user_query)

        # Step 2 - Retrieve relevant information from the DB
        retrieved_info = self.information_retriever.retrieve_information(
            query=refined_query,
            product_id=product_asin
        )

        # Step 3 - Check if the query is answerable
        if not self.is_answerable_agent.check_answerability(
            user_question=refined_query,
            retrieved_info=retrieved_info
        ):
            self.memory.chat_memory.messages.append(HumanMessage(content=user_query))
            return "I'm sorry, but I can't answer that question. This may be due to insufficient information. Try asking something else."

        # Iterate up to 5 times
        iteration = 0
        while iteration < 5:

            # Step 4 - Generate answer
            answer = self.answer_generator.generate_answer(
                user_question=refined_query,
                context=retrieved_info
            )

            # Step 5 - Check answer relevance
            is_relevant = self.is_relevant_generator.assess_relevance(
                user_question=refined_query,
                generated_response=answer,
                context=retrieved_info
            )

            if is_relevant:

                self.memory.chat_memory.messages.append(HumanMessage(content=user_query))

                # Step 6 - Generate follow-up questions
                followup_questions = self.followup_generator.generate_follow_ups(
                    user_question=refined_query,
                    context=retrieved_info
                )

                final_answer = self._format_final_answer(
                    answer=answer,
                    follow_ups=followup_questions
                )

                self.memory.chat_memory.messages.append(AIMessage(content=final_answer))
                return final_answer

            iteration += 1

        self.memory.chat_memory.messages.append(HumanMessage(content=user_query))

        followup_questions = self.followup_generator.generate_follow_ups(
            user_question=refined_query,
            context=retrieved_info
        )

        final_answer = self._format_final_answer(
            answer=answer,
            follow_ups=followup_questions
        )

        self.memory.chat_memory.messages.append(AIMessage(content=final_answer))
        return final_answer
